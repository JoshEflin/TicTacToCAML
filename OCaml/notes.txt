# Expressions- fundamental building block of functional programming

## Definitions(variables, but they aren't variable)-

` let x = 42;;`
returns
` val x : int = 42`

definitions can contain expressions

syntax. let x = e;;
                ^ any expression  
            ^ identifier

Evaluate e to value v--> then bind v to x, and x will always evaulate to v forevermore
  ie. x is a constant pointer to a constant value. NOTHING is mutable

IMPORTANT!-
--Definitions bind a value to a name and have no value themselves
--cannot use definitions within expressions. UNLESS you use a "let expression"

let expressions-
-- let a = 0 in a;;
                ^ in this expression-- let the a in this expression  be bound to 0
             ^ keyword
       ^ is bound to value 0

 HOWEVER a is not contained in the global scope. its in the scope of the expresion itself. 
# if statements
if e1 then e2 else e3
e1 must eval to bool, e2 and 3 must be of same type.

Anonymous Functions 
 https://www.youtube.com/watch?v=Ci48kqp11F8&ab_channel=geoffreymvoelker
 lol
` fun x -> x + 1;;`
returns
` : 'a -> int = <fun>`
there is some function that takes in an argument that returns an int


Function application
(fun x y -> x - y) ( 3*2) (2-1);;
yields 6 - 1
5

let inc = fun x -> x + 1 ;;
val inc : int -> int = <fun>

OR

let inc x = x + 1;;

you can avoid the extra syntax by placing the argument on the left hand side of the '='
this seems similar to the js syntax:
const function = (x) => x + 1;
'const function' --> 'let', 
'(x) =>'  --> 'x =',
and the return value stays the same.

EG.
(fun x -> x + 1) 2;;
IS SEMANTICALLY EQUIVALENT TO
let x = 2 in x + 1;;

in both cases we end up evaluating (x + 1) to determine the final value.

(fun x -> x + 1) 2;;
 there is a function that takes in an x and returns x + 1 and I'm giving i the argument 2 AS x

let x = 2 in x + 1;;
 I'm about to give you an expression  x + 1 and IN that expression let x = 2

recursive functions require  that you specify with "rec"

let fact n = 
  if n =  0 then 1
  else n * fact (n - 1)

does not return

let rec fact n = 
  if n =  0 then 1
  else n * fact (n - 1) 
---note that these parenthesis are required here because the Compiler would otherwise consider n to be the first argument to the fact function
---this would result in an infinite loop.

function type
 t -> u
 a function that takes in a t then returns a u
 t1 -> t2 -> u
  one function that takes in 2 parameters t1 and t2 and then returns a u 
  --- I dont understand why this doesn't represent function chaining..
